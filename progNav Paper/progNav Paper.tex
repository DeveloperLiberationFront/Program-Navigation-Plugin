\documentclass[conference]{IEEEtran}
\usepackage{cite}
\usepackage{graphicx}
\usepackage{multirow}
\usepackage{amssymb}
\usepackage{siunitx}
\usepackage{dcolumn}
\usepackage{color, colortbl}

\usepackage{caption}
\usepackage{subcaption}
\definecolor{Gray}{gray}{0.9}


% correct bad hyphenation here
\hyphenation{op-tical net-works semi-conduc-tor}


\newcommand{\toolName}{Flower}

\begin{document}
%
% paper title
% Titles are generally capitalized except for words such as a, an, and, as,
% at, but, by, for, in, nor, of, on, or, the, to and up, which are usually
% not capitalized unless they are the first or last word of the title.
% Linebreaks \\ can be used within to get better formatting as desired.
% Do not put math or special symbols in the title.
\title{\toolName: Navigating Program Flow in the IDE}


% author names and affiliations
% use a multiple column layout for up to three different
% affiliations
\author{\IEEEauthorblockN{Chris Brown, Justin Smith, Tyler Albert, and Emerson Murphy-Hill}
\IEEEauthorblockA{Department of Computer Science\\
North Carolina State University\\
Raleigh, North Carolina 27606\\
Email: \{dcbrow10, jssmit11, tralber2\}@ncsu.edu, emerson@csc.ncsu.edu}
}

% make the title area
\maketitle

% As a general rule, do not put math, special symbols or citations
% in the abstract
\begin{abstract}
Program navigation is a critical task for software developers. 
%Many tools and approaches have been proposed to aide developers in navigating programs.
%In this work we present a tool, \toolName~, that enables developers 
Unfortunately, the current state-of-the-art tools do not adequately support developers in simultaneously navigating both control flow and data flow (i.e. program flow). 
To assist developers in effectively navigating program flow we designed and implemented a tool that leverages powerful program analysis techniques while maintaining low barriers to invocation.
Our tool enables developers to navigate program flow upstream and downstream within the Eclipse Integrated Development Environment (IDE).
Based on a preliminary evaluation with 8 programmers, our tool compares well to existing tools. 
%We present a different way to do things... enable the navigation control flow and data flow simultaneously using minimal interface alterations.
%Something about tradeoffs.
%For simple sub-tasks tool was effective with very few interface elements. 
\end{abstract}

% no keywords



\IEEEpeerreviewmaketitle


\section{Introduction}
Modern software systems contain millions of lines of source code. 
As software grows in size and complexity, developers increasingly rely on tools to help them navigate the programs they create. Finding and fixing bugs has become the most common software activity taking up 70-80\% of software engineers' time \cite{Whyline}, and a software testing study described a wide variety of tools developers use to validate their code in different ways but also found that inadequate testing and debugging tools were a contributing factor to buggy poor quality software in production\cite{NIST-02-3}.
Program navigation is a central task that can help improve developers' program comprehension, which Brooks argues is vital because this type of domain-specific knowledge plays a key role in nearly every software tasks including development, code reviews, debugging, code maintenance, testing, and more \cite{BrooksComprehension}. Code navigation can also be applied to exploring new code bases and assessing security vulnerabilities. 

Integrated development environments (IDEs) present code linearly in the order methods are defined. 
However, successful developers do not navigate source code linearly (line by line starting at the top of the file). 
Instead, they methodically navigate the code's hierarchical semantic structures~\cite{robillard2004investigate}.
While navigating programs, developers ask questions about control flow and data flow throughout the program~\cite{latoza2010hard, Smith2015}. 
We will refer to these two concepts together as \textit{program flow}. 

To realize their ideal program flow navigation strategies, developers rely on navigation tools that expose the links between distant locations in the source code. 
Many existing tools do so by displaying call graph visualizations or adding views to the the screen.
In general, evaluations have demonstrated the effectiveness of such tools ~\cite{Reacher,Whyline,Relo,Stacksplorer}.

However, these tools rely on cumbersome user interface widgets that new users might struggle to understand and occupy valuable screen real estate.
We present a tool, \toolName, that represents a minimalistic approach to program navigation.
\toolName~ leverages powerful program analysis techniques and integrates all of its results into the code view.
In evaluating \toolName, we want to understand what types of tasks it can effectively support withoult leaning on the the additional user interface elements that characterize other tools.
%Existing tools feature many cumbersome UI widgets or seem poorly integrated into the IDE.
%Previous approaches help developers navigate control flow by helping them visualize. 
%The additional graphs, maps, and visualizations have been shown to help developers stay oriented. However, (occupy a lot of screen real estate, may be difficult for new users to understand, mapping stuff). 
%Also, don't help developers navigate both flows at the same time.   

In this work we designed, implemented, and evaluated a program navigation tool, \toolName.
In contrast to existing navigation tools, \toolName~embodies four key design principles (Section \ref{DesignPrinciples}) that enable developers to simultaneously trace data flow and control flow within the code view. 

%This paper makes the following contributions:
\section{Motivating Example}
\label{MotivatingExample}
Consider Hillary, a professional Java developer at a large software company.
While maintaining some old code, Hillary notices a warning from a static analysis tool --- ``This variable contains user-provided data. If it is used in a sensitive context before being sanitized, this code could be vulnerable to various security vulnerabilities.''

She vaguely recalls that Eclipse provides tools to help her trace control flow and data flow throughout the program, but is unsure how to invoke them.
She spends some time looking through various menus, tries out a few tools, but cannot locate the right tool.
Turning her attention back to the code, she begins scrolling through the current file, scanning for uses of the variable. 
Satisfied she has inspected all the occurrences in the current file, she now searches globally for the variable.
Frustratingly, her search returns an overwhelming number of irrelevant results, including references to the variable's name in comments and documentation.
Unsure of whether the the variable gets sanitized or if it gets used in a sensitive context, she decides to ignore the warning.
%Two months later an attacker exploits the vulnerability, costing her company hundreds of millions of dollars. Hillary gets fired for her oversight. Without her high-paying job, she can no longer afford to feed her kids and pay her mortgage. Drowning in credit card debt, homeless, and divorced, Hillary curses the Eclipse tools that let her down.   
Though Hillary is fictional, her story is based on the experiences of real developers we observed in a previous study~\cite{Smith2015}.
\section{Design Principles}
\label{DesignPrinciples}
In this section we describe the design principles that we used to shape \toolName. We derived these design principles from a previous study \cite{Smith2015} and by examining existing program navigation tools.
 
\vspace{1em} 
\noindent\textbf{Powerful Program Analysis} ---
Simple textual analysis may lead to inaccurate results in many scenarios. For example, such analysis fails when programs include duplicated variable names that refer different variables in different scopes. Textual analysis also falls short when programs contain inheritance and when variable names are included in comments, documentation, or other syntactically irrelevant locations.
By leveraging powerful program analysis techniques, navigation tools can provide more accurate information than simple textual analysis.
By analyzing abstract syntax trees (ASTs) and call graphs, tools can make references to relevant variables and methods. 

\vspace{1em} 
\noindent\textbf{Low Barriers to Invocation} ---
Some tools are easier to invoke than others. 
Tools with high barriers to invocation require users to sift through menus and include unintuitive widgets. 
Barriers to invocation inhibit adoption. 
As developers navigate multiple program paths concurrently, repetitively invoking tools may be cumbersome, especially if barriers are high. 


\vspace{1em} 
\noindent\textbf{Full Program Navigation}  ---
Developers are not only interested in traversing programs' call graphs, but also how data flows through the call graph.
To do so, developers must inspect the relationship between methods as well as the methods themselves.
Often the methods of interest span across multiple source files.
Furthermore, program navigation tools should support this traversal both upstream and downstream. 
That is, tools should highlight variable assignments and also subsequent variable uses. 

\vspace{1em} 
\noindent\textbf{In Situ Navigation}  ---
Switching between views in the IDE can cause disorientation~\cite{deAlwis2006disorient}. As developers navigate through code, navigation tools should present their results in that context. 
When navigation tools present results outside the code, developers are burdened with the cognitive load of translating those results back to the code.

\section{Background}
%Summary of related work, including a table evaluating existing %tools on various design principles.
%Spoiler alert, none of the tools satisfy all of the principles.
There are a variety of tools available to help developers explore and navigate code. Here we discuss two types of tools, production tools and visualization tools and Table \ref{table:background} shows a comparison between \toolName~ and other related tools in terms of the four design principles used to implement our tool.

\subsection{Production Tools}
Production tools are represented by plugins in integrated development environments that provide detailed information and analysis on variables and methods in the source code. Examples of these types of tools include \emph{Call Hierarchy} and \emph{Find References} in Eclipse\cite{Eclipse} and \emph{Analyze Data Flow To/From Here} and \emph{Analyze Dependencies} in IntelliJ\cite{IntelliJ}. These tools provide powerful program analysis for users to navigate throughout the entirety of a project, however they generally differ from our tool in that they may require multiple steps to start the tool or modify the user's navigation (i.e. switching between up and down search), may need repeated invocations of the plugin to track multiple paths or variables in the code, and force users to switch between the text editor of the IDE and a new panel displaying the results.

There are also several production tools that are strictly consolidated within the editor. Two examples of these types of commercial tools include \emph{Mark Occurrences}\cite{MarkOccurrences} and \emph{Open Declaration} in the Eclipse IDE. These approaches are similar to our tool in that they display the results within the editor rather than a separate view or panel, but in some cases they may not provide a detailed enough analysis to explore the entire program or provide extra unnecessary information, for example Mark Occurrences only highlighting the instances of data within a class in addition to highlighting the value in a comment. These can require repeated work to start the tool, such as Open Declaration requiring the user to right-click or enter a keyboard shortcut for each method or variable declaration the user wants to open.

\subsection{Visualization Tools}
Code navigation tools that provide users with a graphical representation of the results are visualization tools. Some examples of these types of tools include \emph{Code Bubbles}\cite{CodeBubbles}, \emph{Code Canvas}\cite{CodeCanvas}, \emph{Code Surfer}\cite{CodeSurfer}, \emph{Dora}\cite{Dora}, \emph{Reacher}\cite{Reacher}, \emph{Relo}\cite{Relo}, \emph{Whyline}\cite{Whyline}, and many more research tools. These works provide various views of control flow graphs, class and UML-like diagrams, trees, call graphs, and other images to describe the hierarchy and relationship between different variables or functions within the code. \toolName~differs because, while all visualization tools can provide powerful data analysis, but we desire minimal steps to invoke the tool and present the information inside of the editor.

\begin{table}
	\centering
	\caption{Design Principles}
	\begin{tabular}{c|c|c|c|c}
		\rowcolor{Gray}
		\hline
		Tools & Powerful & Low & Full Prog. & In Situ\\
		\rowcolor{Gray}
		 & Analysis & Barriers & Nav. & Nav.\\
		\hline
		Call Hierarchy & \checkmark & - & \checkmark & -\\
		\rowcolor{Gray}
		Find References & \checkmark & - & \checkmark & -\\
		Analyze Data Flow & \checkmark & - & \checkmark & -\\
		\rowcolor{Gray}
		Analyze Dependencies & \checkmark & - & \checkmark & -\\
		Mark Occurrences & - & \checkmark & - & \checkmark \\
		\rowcolor{Gray}
		Open Declaration & \checkmark & - & \checkmark & \checkmark \\
		Code Bubbles & \checkmark & - & \checkmark & \checkmark \\
		\rowcolor{Gray}
		Code Canvas & \checkmark & - & \checkmark & \checkmark \\
		Code Surfer & \checkmark & - & \checkmark & Sometimes \\
		\rowcolor{Gray}
		Dora & \checkmark & - & \checkmark & - \\
		Reacher & \checkmark & - & \checkmark & - \\
		\rowcolor{Gray}
		Relo & \checkmark & - & \checkmark & - \\
		Whyline & \checkmark & - & \checkmark & - \\
		\hline
	\end{tabular}
	\label{table:background}
\end{table}


\section{\toolName}
\toolName~was designed to realize all of the principles described in Section \ref{DesignPrinciples}. 
We implemented \toolName~as a plugin to the Eclipse IDE~\cite{Eclipse}. 
We chose Eclipse because of its popularity and extensibility. 
Eclipse is one of the most widely used open source IDEs for Java development and it provides many extension points for plugins. 

Figure \ref{fig:tool} depicts \toolName~invoked on a variable participants were asked to inspect as part of our evaluation. To visualize how a programmer would interact with \toolName, consider the following scenario:


Suppose you are a programmer and you notice that by modifying the value of the \texttt{fileName} variable, users could gain access to sensitive information in the database. 
You want to determine whether users can modify \texttt{fileName} before it gets passed into \texttt{getQueries} or if \texttt{fileName} is always bound to hard-coded parameters. 
First, you click on \texttt{fileName} (A). 
To help you locate where the variable is modified and referenced, \toolName~highlights occurrences of that variable in the code.
Since \texttt{fileName} is a formal parameter to \texttt{getQueries}, any method calling \texttt{getQueries} could modify \texttt{fileName}. 
Those methods reside in other class files, so \toolName~ provides links to their locations (B1).
Rather than move your mouse up to the top of the editor window, you click on \texttt{getQueries} (B2), which conveniently links to the first call site, \texttt{createTables}. 
\toolName~ opens \texttt{createTables} and highlights the location in that method where fileName is passed to \texttt{getQueries} as seen in Fig. \ref{fig:tool}.  
Additionally, if the selected variable has uses that do not appear in the user's current view of the editor then the tool will provide links to those off-screen line numbers in the top box if it appears above the current location and in the bottom box if it is used below (not shown).

%Something about using \toolName for down flow.
%(A) - When a user clicks on a variable all (visible) instances of that variable are highlighted in the code. (B) - When the variable has been declared as a parameter to the current method, users can click on that method's name in the editor to navigate to a location where that method is called. (X) - When the variable is passed to an external method, users can click on that method's name to open its declaration. (C) - If the variable is passed in from another method or is defined earlier in the current file, a link to that location is displayed in the ``top box.'' (D) - If the variable is passed in to another method or referenced later in the current file, links to those locations appear in the ``bottom box.''

\begin{figure*}
\begin{subfigure}{\textwidth}
  \includegraphics[width=.4\linewidth, height=3cm]{images/toolScreenshot1}
  \label{fig:sub1}
\end{subfigure}%
\begin{subfigure}{\textwidth}
  \includegraphics[width=.6\linewidth, height=3cm]{images/toolScreenshot2}
  \label{fig:sub2}
\end{subfigure}
\caption{Code view in the Eclipse IDE with \toolName~invoked on the method \texttt{getQueries} from Task 1}
\label{fig:tool}
\end{figure*}


\begin{table}
\centering
\caption{Participant Demographics}
\begin{tabular}{cSScc}
\rowcolor{Gray}
\hline
\multicolumn{1}{c}{\textbf{Participants}} & \multicolumn{1}{c}{\textbf{Industry}} & \multicolumn{1}{c}{\textbf{Java}} &\multicolumn{1}{c}{\textbf{Used}} & \multicolumn{1}{c}{\textbf{Task}} \\
\rowcolor{Gray}
\multicolumn{1}{c}{ } & \multicolumn{1}{c}{\textbf{Exp.} \textit{(years)}} & \multicolumn{1}{c}{\textbf{Exp.} \textit{(years)}} & \multicolumn{1}{c}{\textbf{Eclipse}} & \multicolumn{1}{c}{\textbf{Group}}\\
\hline
P1 & 9 & 5 & \checkmark & T1* - T2 \\
\rowcolor{Gray}
P2 & 0 & 6 & \checkmark & T2* - T1\\
P3 & 3 & 2 & - & T1 - T2*\\
\rowcolor{Gray}
P4 & 5 & 0 & - & T2 - T1*\\
P5 & 12 & 10 & \checkmark & T1* - T2\\
\rowcolor{Gray}
P6 & 0 & 3.5 & \checkmark & T2* - T1\\
P7 & 1 & 9 & \checkmark & T1 - T2*\\
\rowcolor{Gray}
P8 & 5.5 & 3.5 & \checkmark & T2 - T1*\\
\multicolumn{5}{c}{* Used \toolName~for task}
\end{tabular}
\label{table:participants}
\end{table}

\section{Preliminary Evaluation}
We performed a preliminary evaluation of \toolName~ with eight programmers performing two code navigation tasks.
As a baseline, we compare our tool against the existing suite of tools available in Eclipse (Open Declaration, Mark Occurrences, and Call Hierarchy).
Our goals in this study were to (a) get feedback on the usability of \toolName~ and (b) determine what types of navigation activities \toolName~ effectively supports.
Section \ref{UsabilityMethodology} outlines our approach to answering (a).
To answer (b), we measured how quickly and accurately participants completed different activities.
The remainder of this section describes our participants, study design, and task selection.

All participants were graduate students at the time of the study with a mean of 5 years of professional programming experience; Table \ref{table:participants} provides additional information about each participant. We recruited participants using a convenience sampling approach. 
Before the study, we asked participants to report whether they were familiar with the Eclipse IDE. We used this information to balance Eclipse novices across groups.

Each participant used \toolName~for one task and Eclipse's tools for the other task.
To control for learning and fatigue effects, we used a 2x2 latin square design which permuted the order participants received each tool and performed each task. 
Accordingly, each participant was assigned to one of four groups (Task Group column in Table \ref{table:participants}).

We analyzed the data from our previous study~\cite{Smith2015}, which included two tasks that required program flow navigation.
In the previous study, developers expressed a willingness to navigate the program, but used sub-optimal strategies to do so.
Because the challenges participants faced in ~\cite{Smith2015} partially inspired the development of \toolName, we include the same two tasks in this study.

The two tasks we chose are complementary in that Task 1 required participants to navigate up the call graph, inspecting the callers of the initial method. 
On the other hand, Task 2 required participants to inspect the methods called by the initial method.
For Task 1 we asked participants to tell us whether a method ever receives user-provided input.
For Task 2 we asked participants to tell us whether a form field is validated before being sent to the database.
To ensure all participants had a baseline familiarity, we trained participants on the appropriate tools preceding each task. 
To evaluate the effectiveness of the navigation tools rather than participants' familiarity with a particular code base, we asked participants to navigate code they had not previously contributed to. 
Because think aloud protocols distort the amount of time required to complete tasks, we did not interrupt or prompt participants until after they had completed the tasks.

%We chose two tasks that (differentiate between the two tasks... up and down?)

\subsection{Usability Evaluation}
\label{UsabilityMethodology}
To evaluate the usability of \toolName, we administered an adapted version of the Post-Study System Usability Questionnaire (PSSUQ)~\cite{Lewis95ibmcomputer} after participants had completed both tasks. We modified the questionnaire by replacing ``this system'' with ``this tool'' and asked questions from the System Quality and Interface Quality categories. We asked 10 questions; participants responded on a 7-point Likert scale from ``Strongly Disagree'' to ``Strongly Agree.'' 	
To prompt discussion about the usability of \toolName, we also asked participants open-ended questions based on applicable categories from Nielsen's usability heuristics~\cite{Nielsen1992}.
%To capture participant's experiences that these two metrics overlooked, two of the authors independently examined each audio/video recording and recorded memos. 

\section{Results}
\begin{figure}
	\centering
	\includegraphics[width=\columnwidth]{images/taskTime}
	\caption{Mean time to complete each task with and without \toolName}
	\label{fig:taskTime} 
\end{figure}

\textbf{Approachable Interface:}
On the PSSUQ, participants responded most positively to questions about \toolName's simplicity, how easy it was to use, and how easy it was to learn. 
The median response to these three questions was 6.
These responses seem to indicate that participants were most enthusiastic about \toolName's minimalistic interface. 
Participants reiterated these sentiments in their responses to the open-ended questions. 
For the most part, participants felt it was easy to remember how to use \toolName~and that it featured a ``consistent interface.''

\textbf{Branchless Navigation:}
For Task 1, all participants correctly navigated up the call graph.
The first two steps in this task involved navigating a portion of the call graph that did not include any branches.
In other words, participants started in the \texttt{parseSQLFile} method, which was only called in one location, \texttt{parseAndCache}. 
The \texttt{parseAndCache} method was itself only called in one method \texttt{getQueries}.
Participants equipped with our tool were strictly faster in navigating the first step up this branchless chain. 
The mean times for participants to reach \texttt{parseAndCache} with \toolName~and the Eclipse tools were 8 seconds and 44 seconds, respectively.
These two results suggest that \toolName~successfully adhered to the \textit{Low Barriers to Invocation} design principle. 

\textbf{Get Me Outta Here:}
For Task 2, participants were more accurate with \toolName.
Two participants (P3 and P6) navigated to the correct validation method with \toolName.
Only one (P8) did so with the Eclipse tools.

However, the mean completion time for Task 2 with \toolName~was higher (Figure \ref{fig:taskTime}).
Additionally, participants who used \toolName~ for Task 2 scored the tool lower on the PSSUQ than those who used it for Task 1.
Based on open-ended responses and our observations of participants, we provide one likely explanation for this deficiency.
Participants were required to sift through more confounding variables and branches to complete Task 2.
When participants took missteps they found it difficult to retrace their navigation path.
While working on Task 2 with \toolName~P6 attempted to use Eclipse's built-in back buttons to backtrack, but still had difficulty reorienting himself. 
To a lesser extent, we observed this same difficulty during Task 1.
After navigating through several chains of method invocations with \toolName, P7 felt like she had reached a ``dead end'' and was unsure of how to navigate back to where she came from.
Similarly, after reaching a top-level method, P1 asked, ``How can I return back to where I came from?''

%PSSUQ responses support this. Could talk about the low categories
%On the other hand, participants responded most negatively to questions about whether the tool provided all the expected functions and capabilities and whether it would enable them to complete tasks quickly.
%All the functions I expected (Missing tracability and mark bars, ... )
%To these two questions, participants' median response was 5. 


%Overall, task competion time distorts the actual time participants took to complete the task.
%Participants who explored more of the call graph are penalized. 
%Some participants spent additional time exploring after finding the right answer to confirm their conclusion

%(Not sure how to report correctness here... 4 gave the correct answer with eclipse tools --
%2 were correct with ours. However, the incorrect two navigated correctly, located a hard-coded %parameter, responded incorrectly, and did not justify)
%However, participants were Y\% slower for Task 2.
%(Correctness in terms of navigation was even split. One with our tool guessed correctly)

%To understand why participants were faster for Task 1 with \toolName, we analyzed how long it took participants to navigate one step up the call graph. 

%DFS exploration stategies

\section{Discussion}

\subsection{Systematic Navigation}
Participants completed simple navigation tasks quickly and accurately with \toolName, perhaps due to its minimalistic interface.
However, when the task required participants to navigate more complex semantic structures, participants demanded features that would allow them to navigate more systematically.
Many existing tools support systematic exploration through the use of secondary views containing either hierarchically structured lists of methods (e.g. \textit{Call Hierarchy} and \textit{Analyze Data Flow}) or call graph visualizations (e.g. \textit{Reacher}).
In keeping with \toolName's minimalistic design and trying to preserve \toolName's \textit{Low Barriers to Invocation}, we envision several design changes that might enable \toolName~ to support more systematic navigation.
By tracking developers progress, \toolName~ could display already-visited locations differently than unexplored methods either positionally or through the use of colors.
Additionally, \toolName~ could use animation to transition more smoothly between locations, perhaps giving users a sense of naturally moving through the code.
%Especially important when participants reach ``dead ends.'' When we detect that, intervene!
%animations, breadcrumbs, detect dead ends, reorganize links to 


\subsection{Synergistic Tools}
Navigation without any dedicated tools can be frustrating and unfruitful (Section \ref{MotivatingExample}). 
However, full-featured navigation tools might be too cumbersome for simple navigation tasks and too complex for unfamiliar users. 

Admittedly, \toolName's minimalistic interface omits many features that could help orient developers as they navigate complex program flows.

For the purposes of this evaluation we observed programmers using \toolName~ in isolation.   

	
Overwhelmed when the call graph had a high branching factor.
	Participants quickly navigated up single paths as in Task 1
	When call paths branched in many directions our tool could reccomend more full featured tools.\\


%Performance.
%Whenever the user clicks on a new variable \toolName~ has to search through the entire project for locations where the method is declared or invoked. We observed that participants navigated within one file more often than between files. To improve the performance of our tool, we could optimize the search to return local results before returning global search results.	Participants also repeated invocation on the same variables (we could do some caching)


\section{Limitations}

\section{Conclusion}

%\section*{Acknowledgment}

The authors would like to thank...





% trigger a \newpage just before the given reference
% number - used to balance the columns on the last page
% adjust value as needed - may need to be readjusted if
% the document is modified later
%\IEEEtriggeratref{8}
% The "triggered" command can be changed if desired:
%\IEEEtriggercmd{\enlargethispage{-5in}}

% references section

% can use a bibliography generated by BibTeX as a .bbl file
% BibTeX documentation can be easily obtained at:
% http://mirror.ctan.org/biblio/bibtex/contrib/doc/
% The IEEEtran BibTeX style support page is at:
% http://www.michaelshell.org/tex/ieeetran/bibtex/
\bibliographystyle{IEEEtran}
% argument is your BibTeX string definitions and bibliography database(s)
\bibliography{progNavPaper}




% that's all folks
\end{document}
